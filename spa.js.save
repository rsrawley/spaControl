/* Use

node spa.js 2>&1 | tee test1 &

in order to see output on terminal and save it to file
*/

// Don't forget every number from the hot tub is in hexadecimal !!!

// Set up command line access
cmd = require('node-cmd')

// Check every minute for internet connectivity
checkConnectivity(0);

function checkConnectivity(numFails) {
	cmd.get('ping -c 5 8.8.8.8',
		function(err, data, stderr){
			if (err) {
				numFails++;

				if (numFails == 5) {
					cmd.run('sudo ifdown wlan0 && sudo ifup wlan0')
				} else if (numFails == 10) {
					cmd.run('sudo reboot')
				}
			} else {
				numFails = 0
			}
			setTimeout(function(){checkConnectivity(numFails)},60000) // Every minute
    }
	)
}

// Set up GPIO access
let gpio = require('onoff').Gpio;
let Vcc = new gpio(18,'high'); // Physical pin 12
let RE_DE = new gpio(23,'low'); // Physical pin 16

// Release all GPIOs on exit
process.on('SIGINT', function () {
	Vcc.unexport();
	RE_DE.unexport();
	process.exit()
})

// Set up web server
const express = require('express'); // Web server
const app = express();
const server = require('http').createServer(app);
server.listen(9000); // Start the webserver on port 9000
app.use(express.static(__dirname + '/html')); // Tell the server location of the static web pages

// Web socket server
io = require('socket.io').listen(server);

io.on('connection', function(socket){
  // Initial connection: send all params to client that just connected
  for (let key in spa) {
		if (key != "outbox" && key != "temp") { // "temp" can be removed -- it's for helping finding codes
			io.emit('data',{"id" : key, "value" : spa[key]});
		}
	}

	// Send initial graph data
	io.emit('graphData',graphData);


  // Messages received
  socket.on('command', function(command) {
  	console.log('SOCKET.IO - Received message: ' + JSON.stringify(command));
		sendCommand(command.type,command.param,checkError);
  })
})


// Sends message back if an error in sending command
function checkError(error) {
	io.emit('error',error);
	console.log(error);
}


// Every minute, check the time is right and adjust (if spa turned off, or daylight saving change)
setInterval(function () {setTime()},60000)

// Every 10 minutes, store spa temperature in array and write to file


function setTime() {
	if (spa.HH != undefined) { // Make sure we already have a connection
		// It's easier to use JS date objects to handle checking before and after midnight
		let currentDate = new Date();
		let hours = currentDate.getHours();
		let minutes = currentDate.getMinutes();

		let spaTime = new Date(2019,10,19,parseInt(spa.HH,16),parseInt(spa.MM,16)); // October 19, 2019 is an arbitrary date (I happened to work on this function that day)

		// As long as spa time is within +/- 1 min of actual time, we're not modifying it
		let lowerLimit = new Date(2019,10,19,hours,minutes - 1);
		let upperLimit = new Date(2019,10,19,hours,minutes + 1);
		if (!(spaTime.getTime() >= lowerLimit.getTime() && spaTime.getTime() <= upperLimit.getTime())) { // If not in right time, change it
			sendCommand("setTime",[hours,minutes],checkError);
//			console.log(lowerLimit,spaTime,upperLimit,spa.HH,spa.MM)
		}
	}
}

// Store all items in memory
let spa = {
	outbox : [], // Messages waiting to be sent to spa
};

spa.testing=[]; // Only used for testing (displaying changes in configs)

// Set up message translation matrix (codes must be unique as they are used to store data in spa{})
let incoming = { // Status update
	"ff af 13" : {
		"description" : "Status udpate",
						    //17 00 62 15 0a 00 00 00 00 08 0c 00 00 02 00 00 00 00 00 04 60 00 00 00 1e 00 00
		"codeLine" : "GF PF CT HH MM HM 00 TA TB FC HF PP 00 CP LF 00 00 00 00 CC ST TC 00 00 H2 00 00".split(" "),
		"codes" : {
			"GF" : "General flag (05 = on hold)",
			"PF" : "Priming flag (on start, goes through different stages: 04,42,05,01,00 ---0x01 = Priming)",
			"CT" : "Current temperature (in F) -- 00 means no temp reading", // verified
			"HH" : "Hours", // verified
			"MM" : "Minutes", // verified
			"HM" : "Heating mode (0x00 = Ready, 0x01 = Rest, 0x03?? = Ready in rest))", // verified for 0 and 1
			"TA" : "Temp sensor A (inlet) (show hold remaining time if on hold : goes to 3c (60 min) first, then drops by 1 every minute)", // verified
			"TB" : "Temp sensor B (outlet)", // verified
			"FC" : "Filter cycle (04(low)/06(high) = cycle 1, 08(high) = cycle 2, ?? = both?? FC goes to 00 briefly when switching?)", // verified
			"HF" : "Heat flag (0x04 = on hold in temp range high, 0x0c = not heating (high), 0x2c = waiting (high), 0x1c = heating (high), subtract 4 from all values for low range)", // verified
			"PP" : "Pump status (0x02 for pump 1, 0x08 for pump 2, 0x0a for both -- added together)", // verified
			"CP" : "Circ pump (0x00 = off, 0x02 = on)", // verified
			"LF" : "Light flag (0x03 for on)", // verified
			"CF" : "Cleanup cycle flag (0x04 off, 0x0c for on)",
			"ST" : "Set temperature", // verified
			"TC" : "Temperature A/B flag (0x00 = off, 0x01  = on)",
			"H2" : "Heat mode 2nd flag (0x00 = when HM is 01, 0x1e = when HM is 00, also goes to 00 if M8 set to off and goes back to 1e if M8 set to on)" // could be timer on m8?
		}
	},

	"10 bf 23" : { // Filter configuration
		"description" : "Filter configuration",
		"codeLine" : "1H 1M 1D 1E 2H 2M 2D 2E".split(" "),
		"codes" : {
			"1H" : "Filter 1 start hour (always 0-24)",
			"1M" : "Filter 1 start minute",
			"1D" : "Filter 1 duration hours",
			"1E" : "Filter 2 duration minutes",
			"2H" : "Filter 2 start hour, masking out the high order bit, which is used as an enable/disable flag (mod 128)",
			"2M" : "Filter 2 start minute",
			"2D" : "Filter 2 duration hours",
			"2E" : "Filter 2 duration minutes"
		}
	},

	"10 bf 24" : { // Control configuration 1 ***seems same as ff af 26***!!!!!!!
		"description" : "Control configuration 1",
						 	 // 64 c9 2c 00 4d 42 50 35 30 31 55 58 03 a8 2f 63 83 01 06 05 00
		"codeLine" : "00 00 00 00 B1 B2 B3 B4 B5 B6 B7 B8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"B1 to B8" : "Motherboard model in ASCII"
		}
	},

	"10 bf 25" : { // Control configuration 2
		"description" : "Control configuration 2",
						 	 // 09 03 32 63 50 68 49 03 41 02
		"codeLine" : "00 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
		}
	},

	"10 bf 26" : { // Control configuration 3
		"description" : "Control configuration 3",
						 	 // 00 87 00 01 00 01 00 00 01 00 00 00 00 00 00 00 00 00
		"codeLine" : "00 00 RM TS TF CC 00 00 M8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"RM" : "Reminders (0 = on, 1 = off)",
			"TS" : "Temperature scale (0 = Fahrenheit, 1 = Celsius)",
			"M8" : "M8 artificial intelligence (0 = off, 1 = on)",
			"TF" : "Time format flag (0 = 12h, 1 = 24h)",
			"CC" : "Cleaning cycle length (0 to 8, each integer is 0.5h increments)"
		}
	},

	"10 bf 2e" : { // Control configuration 4
		"description" : "Control configuration 4",
						 	 // 05 00 01 90 00 00
	},

	"10 bf 28" : { // Faults log
		"description" : "Faults log",
						 	 // 0c 0a 10 55 17 21 10 64 60 66 
		"codeLine" : "TO EN EC ND FH FM FE FS FA FB".split(" "),
		"codes" : {
			"TO" : "Total number of entries", // verified
			"EN" : "Entry number (add one to hex number)", // verified
			"EC" : "Error code (see Spa Touch manual for list)", // verified
			"ND" : "Number of days ago", // verified
			"FH" : "Time (hour) of fault", // verified
			"FM" : "Time (minute) of fault", // verified
			"FE" : "Heat mode (01 = ready)", // verified
			"FS" : "Set temp", // verified
			"FA" : "Temp A", // verified
			"FB" : "Temp B" // verified
		}
	},

	"10 bf 2b" : { // GFCI test result
		"description" : "GFCI test result",
						 	 // 01
		"codeLine" : "GF".split(" "),
		"codes" : {
			"GF" : "GFCI test result (0 = not passed, 1 = passed)", // verified
		}
	}
}

// Some response codes have multiple aliases
incoming["ff af 26"] = incoming["10 bf 26"];

// Responses to ignore
let ignore = : "Hours", // verified
			"MM" : "Minutes", // verified
			"HM" : "Heating mode (0x00 = Ready, 0x01 = Rest, 0x03?? = Ready in rest))", // verified for 0 and 1
			"TA" : "Temp sensor A (inlet) (show hold remaining time if on hold : goes to 3c (60 min) first, then drops by 1 every minute)", // verified
			"TB" : "Temp sensor B (outlet)", // verified
			"FC" : "Filter cycle (04(low)/06(high) = cycle 1, 08(high) = cycle 2, ?? = both?? FC goes to 00 briefly when switching?)", // verified
			"HF" : "Heat flag (0x04 = on hold in temp range high, 0x0c = not heating (high), 0x2c = waiting (high), 0x1c = heating (high), subtract 4 from all values for low range)", // verified
			"PP" : "Pump status (0x02 for pump 1, 0x08 for pump 2, 0x0a for both -- added together)", // verified
			"CP" : "Circ pump (0x00 = off, 0x02 = on)", // verified
			"LF" : "Light flag (0x03 for on)", // verified
			"CF" : "Cleanup cycle flag (0x04 off, 0x0c for on)",
			"ST" : "Set temperature", // verified
			"TC" : "Temperature A/B flag (0x00 = off, 0x01  = on)",
			"H2" : "Heat mode 2nd flag (0x00 = when HM is 01, 0x1e = when HM is 00, also goes to 00 if M8 set to off and goes back to 1e if M8 set to on)" // could be timer on m8?
		}
	},

	"10 bf 23" : { // Filter configuration
		"description" : "Filter configuration",
		"codeLine" : "1H 1M 1D 1E 2H 2M 2D 2E".split(" "),
		"codes" : {
			"1H" : "Filter 1 start hour (always 0-24)",
			"1M" : "Filter 1 start minute",
			"1D" : "Filter 1 duration hours",
			"1E" : "Filter 2 duration minutes",
			"2H" : "Filter 2 start hour, masking out the high order bit, which is used as an enable/disable flag (mod 128)",
			"2M" : "Filter 2 start minute",
			"2D" : "Filter 2 duration hours",
			"2E" : "Filter 2 duration minutes"
		}
	},

	"10 bf 24" : { // Control configuration 1 ***seems same as ff af 26***!!!!!!!
		"description" : "Control configuration 1",
						 	 // 64 c9 2c 00 4d 42 50 35 30 31 55 58 03 a8 2f 63 83 01 06 05 00
		"codeLine" : "00 00 00 00 B1 B2 B3 B4 B5 B6 B7 B8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"B1 to B8" : "Motherboard model in ASCII"
		}
	},

	"10 bf 25" : { // Control configuration 2
		"description" : "Control configuration 2",
						 	 // 09 03 32 63 50 68 49 03 41 02
		"codeLine" : "00 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
		}
	},

	"10 bf 26" : { // Control configuration 3
		"description" : "Control configuration 3",
						 	 // 00 87 00 01 00 01 00 00 01 00 00 00 00 00 00 00 00 00
		"codeLine" : "00 00 RM TS TF CC 00 00 M8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"RM" : "Reminders (0 = on, 1 = off)",
			"TS" : "Temperature scale (0 = Fahrenheit, 1 = Celsius)",
			"M8" : "M8 artificial intelligence (0 = off, 1 = on)",
			"TF" : "Time format flag (0 = 12h, 1 = 24h)",
			"CC" : "Cleaning cycle length (0 to 8, each integer is 0.5h increments)"
		}
	},

	"10 bf 2e" : { // Control configuration 4
		"description" : "Control configuration 4",
						 	 // 05 00 01 90 00 00
	},

	"10 bf 28" : { // Faults log
		"description" : "Faults log",
						 	 // 0c 0a 10 55 17 21 10 64 60 66 
		"codeLine" : "TO EN EC ND FH FM FE FS FA FB".split(" "),
		"codes" : {
			"TO" : "Total number of entries", // verified
			"EN" : "Entry number (add one to hex number)", // verified
			"EC" : "Error code (see Spa Touch manual for list)", // verified
			"ND" : "Number of days ago", // verified
			"FH" : "Time (hour) of fault", // verified
			"FM" : "Time (minute) of fault", // verified
			"FE" : "Heat mode (01 = ready)", // verified
			"FS" : "Set temp", // verified
			"FA" : "Temp A", // verified
			"FB" : "Temp B" // verified
		}
	},

	"10 bf 2b" : { // GFCI test result
		"description" : "GFCI test result",
						 	 // 01
		"codeLine" : "GF".split(" "),
		"codes" : {
			"GF" : "GFCI test result (0 = not passed, 1 = passed)", // verified
		}
	}
}

// Some response codes have multiple aliases
incoming["ff af 26"] = incoming["10 bf 26"];

// Responses to ignore
let ignore = 