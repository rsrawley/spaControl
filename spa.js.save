y/*
Balboa controller spa interface
Uses RS485 protocol


Smart heating ?

Winter hours
Time of use: Nov 1 to April 30
7pm to 7am : 10.1 c/kWh off-peak
7pm to 11am : 20.8 c/kWh on-peak
11pm to 5pm : 14.4 c/kWh mid-peak
5pm to 7pm : 20.8 c/kWh on-peak

So let it cool off at 7am - sep temp to 85F
Set to heat at 7pm - set to 96F
*/

/* Use

node spa.js 2>&1 | tee test1 &

in order to see output on terminal and save it to file
*/

// Don't forget every number from the hot tub is in hexadecimal !!!

// Replace [ \t]+\n by \n to get rid of trailing white space

// Set up file access
const fs = require('fs');

// Set up command line access
cmd = require('node-cmd');

// Check every minute for internet connectivity
checkConnectivity(0);

function checkConnectivity(numFails) {
	cmd.get('ping -c 5 8.8.8.8',
		function(err, data, stderr){
			if (err) {
				numFails++;

				if (numFails == 5) {
					cmd.run('sudo ifdown wlan0 && sudo ifup wlan0')
				} else if (numFails == 10) {
					cmd.run('sudo reboot')
				}
			} else {
				numFails = 0
			}
			setTimeout(function(){checkConnectivity(numFails)},60000) // Every minute
    }
	)
}

// Set up GPIO access
let gpio = require('onoff').Gpio;
let Vcc = new gpio(18,'high'); // Physical pin 12
let RE_DE = new gpio(23,'low'); // Physical pin 16

// Release all GPIOs on exit
process.on('SIGINT', function () {
	Vcc.unexport();
	RE_DE.unexport();
	process.exit()
})

// Set up client requests for weather
let request = require("request");
fetchWeather(); // Initial call
setInterval(fetchWeather, 5 * 60000); // Every 5 minutes after that

function fetchWeather() {
	request({"url": "http://192.168.1.58:3000", "json": true}, function (error, response, body) {
		if (!error && response.statusCode === 200) {
			let abort = 0;
			let weather = {};
			let params = { // Weather parameters I want to pick up
				current : ["temperature","feelsLike","wind","windDir","windGust","high","low"],
				hourly : ["hour","icon","temperature","feelsLike","wind","windDir","windGust","POP","rain","snow"]
			};

			for (let key in params) {
				weather[key] = {}; // Avoid undefined
				for (let i=0; i<params[key].length; i++) {
					// If anything goes wrong with weather info lookup, do not update weather values
					if (body[key][params[key][i]] == undefined) {
						abort = 1;
						break
					}

					weather[key][params[key][i]] = body[key][params[key][i]];
				}
			}

			if (abort != 1) {
				spa.weather = weather;
				io.emit('data',{"id" : "weather", "value" : spa.weather}); // Send to all connected clients
			}
		}
	})
}


// Set up web server
const express = require('express'); // Web server
const app = express();
const server = require('http').createServer(app);
server.listen(9000); // Start the webserver on port 9000
app.use(express.static(__dirname + '/html')); // Tell the server location of the static web pages

// Web socket server
io = require('socket.io').listen(server);

io.on('connection', function(socket){
  // Initial connection: send all params to client that just connected
  for (let key in spa) {
		if (key != "outbox" && key != "temp") { // "temp" can be removed -- it's for helping finding codes
			io.emit('data',{"id" : key, "value" : spa[key]});
		}
	}

	// Send initial graph data
	io.emit('graphData',graphData);


  // Messages received
  socket.on('command', function(command) {
  	console.log('SOCKET.IO - Received message: ' + JSON.stringify(command));
		sendCommand(command.type,command.param,checkError);
  })
})


// Sends message back if an error in sending command
function checkError(error) {
	io.emit('error',error);
	console.log(error);
}


// Every minute, check the time is right and adjust (if spa turned off, or daylight saving change)
setInterval(function () {setTime()},60000)

// Every 10 minutes, store spa temperature in array and write to file


function setTime() {
	if (spa.HH != undefined) { // Make sure we already have a connection
		// It's easier to use JS date objects to handle checking before and after midnight
		let currentDate = new Date();
		let hours = currentDate.getHours();
		let minutes = currentDate.getMinutes();

		let spaTime = new Date(2019,10,19,parseInt(spa.HH,16),parseInt(spa.MM,16)); // October 19, 2019 is an arbitrary date (I happened to work on this function that day)

		// As long as spa time is within +/- 1 min of actual time, we're not modifying it
		let lowerLimit = new Date(2019,10,19,hours,minutes - 1);
		let upperLimit = new Date(2019,10,19,hours,minutes + 1);
		if (!(spaTime.getTime() >= lowerLimit.getTime() && spaTime.getTime() <= upperLimit.getTime())) { // If not in right time, change it
			sendCommand("setTime",[hours,minutes],checkError);
//			console.log(lowerLimit,spaTime,upperLimit,spa.HH,spa.MM)
		}
	}
}

// Store all items in memory
let spa = {
	outbox : [], // Messages waiting to be sent to spa
};

spa.testing=[]; // Only used for testing (displaying changes in configs)

// Set up message translation matrix (codes must be unique as they are used to store data in spa{})
let incoming = { // Status update
	"ff af 13" : {
		"description" : "Status udpate",
						    //17 00 62 15 0a 00 00 00 00 08 0c 00 00 02 00 00 00 00 00 04 60 00 00 00 1e 00 00
		"codeLine" : "GF PF CT HH MM HM 00 TA TB FC HF PP 00 CP LF 00 00 00 00 CC ST TC 00 00 H2 00 00".split(" "),
		"codes" : {
			"GF" : "General flag (05 = on hold)", // set to 17 without A/B temperature sensor activated, set to 14 otherwise???
			"PF" : "Priming flag (on start, goes through different stages: 04,42,05,01,00 ---0x01 = Priming)",
			"CT" : "Current temperature (in F) -- 00 means no temp reading", // verified
			"HH" : "Hours", // verified
			"MM" : "Minutes", // verified
			"HM" : "Heating mode (0x00 = Ready, 0x01 = Rest, 0x03?? = Ready in rest))", // verified for 0 and 1
			"TA" : "Temp sensor A (inlet) (show hold remaining time if on hold : goes to 3c (60 min) first, then drops by 1 every minute)", // verified
			"TB" : "Temp sensor B (outlet)", // verified
			"FC" : "Filter cycle (04(low)/06(high) = cycle 1, 08(high) = cycle 2, ?? = both?? FC goes to 00 briefly when switching?)", // verified
			"HF" : "Heat flag (0x04 = on hold in temp range high, 0x0c = not heating (high), 0x2c = waiting (high), 0x1c = heating (high), subtract 4 from all values for low range)", // verified
			"PP" : "Pump status (0x02 for pump 1, 0x08 for pump 2, 0x0a for both -- added together)", // verified
			"CP" : "Circ pump (0x00 = off, 0x02 = on)", // verified
			"LF" : "Light flag (0x03 for on)", // verified
			"CF" : "Cleanup cycle flag (0x04 off, 0x0c for on)",
			"ST" : "Set temperature", // verified
			"TC" : "Temperature A/B flag (0x00 = off, 0x01  = on)", // verified
			"H2" : "Heat mode 2nd flag (0x00 = when HM is 01, 0x1e = when HM is 00, also goes to 00 if M8 set to off and goes back to 1e if M8 set to on)" // could be timer on m8?
		}
	},

	"10 bf 23" : { // Filter configuration
		"description" : "Filter configuration",
		"codeLine" : "1H 1M 1D 1E 2H 2M 2D 2E".split(" "),
		"codes" : {
			"1H" : "Filter 1 start hour (always 0-24)",
			"1M" : "Filter 1 start minute",
			"1D" : "Filter 1 duration hours",
			"1E" : "Filter 2 duration minutes",
			"2H" : "Filter 2 start hour, masking out the high order bit, which is used as an enable/disable flag (mod 128)",
			"2M" : "Filter 2 start minute",
			"2D" : "Filter 2 duration hours",
			"2E" : "Filter 2 duration minutes"
		}
	},

	"10 bf 24" : { // Control configuration 1 ***seems same as ff af 26***!!!!!!!
		"description" : "Control configuration 1",
						 	 // 64 c9 2c 00 4d 42 50 35 30 31 55 58 03 a8 2f 63 83 01 06 05 00
		"codeLine" : "00 00 00 00 B1 B2 B3 B4 B5 B6 B7 B8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"B1 to B8" : "Motherboard model in ASCII"
		}
	},

	"10 bf 25" : { // Control configuration 2
		"description" : "Control configuration 2",
						 	 // 09 03 32 63 50 68 49 03 41 02
		"codeLine" : "00 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
		}
	},

	"10 bf 26" : { // Control configuration 3
		"description" : "Control configuration 3",
						 	 // 00 87 00 01 00 01 00 00 01 00 00 00 00 00 00 00 00 00
		"codeLine" : "00 00 RM TS TF CC 00 00 M8 00 00 00 00 00 00 00 00 00".split(" "),
		"codes" : {
			"RM" : "Reminders (0 = on, 1 = off)",
			"TS" : "Temperature scale (0 = Fahrenheit, 1 = Celsius)",
			"M8" : "M8 artificial intelligence (0 = off, 1 = on)",
			"TF" : "Time format flag (0 = 12h, 1 = 24h)",
			"CC" : "Cleaning cycle length (0 to 8, each integer is 0.5h increments)"
		}
	},

	"10 bf 2e" : { // Control configuration 4
		"description" : "Control configuration 4",
						 	 // 05 00 01 90 00 00
	},

	"10 bf 28" : { // Faults log
		"description" : "Faults log",
						 	 // 0c 0a 10 55 17 21 10 64 60 66
		"codeLine" : "TO EN EC ND FH FM FE FS FA FB".split(" "),
		"codes" : {
			"TO" : "Total number of entries", // verified
			"EN" : "Entry number (add one to hex number)", // verified
			"EC" : "Error code (see Spa Touch manual for list)", // verified
			"ND" : "Number of days ago", // verified
			"FH" : "Time (hour) of fault", // verified
			"FM" : "Time (minute) of fault", // verified
			"FE" : "Heat mode (01 = ready)", // verified
			"FS" : "Set temp", // verified
			"FA" : "Temp A", // verified
			"FB" : "Temp B" // verified
		}
	},

	"10 bf 2b" : { // GFCI test result
		"description" : "GFCI test result",
						 	 // 01
		"codeLine" : "GF".split(" "),
		"codes" : {
			"GF" : "GFCI test result (0 = not passed, 1 = passed)", // verified
		}
	}
}

// Some response codes have multiple aliases
incoming["ff af 26"] = incoming["10 bf 26"];

// Responses to ignore
let ignore = [
	"10 bf 06", // Ready to send command?
	"10 bf 07", // Nothing to send response from panel?
	"fe bf 00", // No idea, emitted every 1 second roughly
	"ff af 13" // Regular status updates (will be caught by functions, doesn't count as "response confirmation" from motherboard)
];

// Set up serial port
const SerialPort = require('serialport');
const Delimiter = require('@serialport/parser-delimiter');
const port = new SerialPort('/dev/ttyAMA0', {
  baudRate: 115200
});
const parser = port.pipe(new Delimiter({delimiter: Buffer.from('7e', 'hex') }));
parser.on('data', readData);

function readData(data) {
	data = data.hexSlice(); // Convert to hexadecimal string

	// Extract message length (first byte) and message type (next 3 bytes)
	let message = {
		"hex" : data.match(/../g).join(" "),
		"length" : parseInt(data.substr(0,2),16), // First byte is length (number of bytes in message) (2 characters in hex per byte, so number of characters is twice this number)
		"type" : data.substr(2,6), // Next 6 bytes is type of message
		"content" : data.substring(8,data.length-2).match(/../g), // Slice to the end (except the checksum) and put into array, split two characters at a time (the hex code)
		"checksum" : data.substr(-2,2) // Last byte is checksum
	}

	// In case no content in message (just contains length, message type and checksum)
	if (message.content == null) {
		message.content = []
	}

	if (data.length == message.length*2 && checksum(data.substring(0,data.length-2)) == message.checksum) { // Check proper message length and checksum

		// Insert spaces every two characters to match "human readable" object type defined at top of program
		message.type = message.type.substr(0,2) + " " + message.type.substr(2,2) + " " + message.type.substr(4,2);

		// For testing purposes
		displayMessages(message.type,message.content)

		// Has a message already been sent to motherboard ?
		// Verify that response is not in ignore list and is not the regular status update -- any other response will be deemed as confirmation of command received
		if (spa.readyToSend == "waiting on response"  && ignore.indexOf(message.type) == -1) {
			spa.readyToSend = "waiting on ready command";
			spa.waitingResponseTries = 0;
//console.log("response confirmation received")
		}

		// Translate message
		if (message.type == "10 bf 06" && spa.outbox.length > 0) { // "Ready for command" (I think??) and messages ready to be sent
//console.log(spa.readyToSend, spa.waitingResponseTries)

// spa.waitingResponseTries is used both to wait for ready command a few times AND for the response confirmation
			if ((spa.readyToSend == "waiting on ready command" && spa.waitingResponseTries == 0) || spa.waitingResponseTries == 30) { // Ready command received or no confirmation received, so giving up
//console.log("executing message function")
				spa.outbox[0](); // Execute first message function in the queue (and probably the only one)
				spa.outbox.shift(); // Remove message function from queue
				spa.readyToSend = "waiting on response";
				spa.waitingResponseTries = 0;

// I think the console.log() is significantly slowing down the timing and causing some message not to be sent at the right time...
			} else if (spa.readyToSend == "waiting on ready command") { // Wait for a few  "Ready command" before sending next message
				spa.waitingResponseTries++;

			} else if (spa.readyToSend == "waiting on response") {
				spa.waitingResponseTries += 1;

			} else { // control variables have not been initialized yet
				spa.readyToSend = "waiting on ready command"
				spa.waitingResponseTries = 0;
			}

		} else if ((message.type in incoming && ignore.indexOf(message.type) == -1) || message.type == "ff af 13")  { // I have a definition for this message type and it is not in the ignore list or it's the regular status update

			let codeLine = incoming[message.type].codeLine; // Order of codes
			let codes = incoming[message.type].codes; // Translation of codes

			// Go through message content and translate byte by byte
			if (codeLine != undefined) { // Has a code line been defined for this message type ?
				for (let i=0; i<message.length; i++) {
					if (codeLine[i] in codes) { // If a code exists in codeLine, store in spa{}
						spa[codeLine[i]] = message.content[i]; // Update items in memory
						io.emit('data',{"id" : codeLine[i], "value" : spa[codeLine[i]]}); // Send to all connected clients
					}
				}
			}
		}
	}
}


function sendCommand(requested,param,callBackError) {
	console.log(requested)
  // Some messages need config requests to be sent first
  let type;
  let content = "";

	if (requested == "toggleItem") { // verified
  	type = "10 bf 11";

		let allowed = {"pump1" : "04", "pump2" : "05", "lights" : "11", "heatMode" : "51", "tempRange" : "50", "hold" : "3c"};
		if (param in allowed) {
			content = allowed[param] + "00";
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "setTemp") { // verified
  	type = "10 bf 20";
//range is 80-104 for F, 26-40 for C in high range
//range is 50-80 for F, 10-26 for C in low range
		if (param >= 50 && param <= 104) { // how to know if in low/high range???
			content = decHex(param);
			spa.lastChangeToTemp = new Date().getTime(); // Keep track of when temperature was changed (because of savElectricity() )
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "setTime") {  // Expects param to be in [HH,MM] format // verified
  	type = "10 bf 21";

		if (param[0] >=0 && param[0] <=23 && param[1] >=0 && param[1] <= 59) { // Check hours and minutes within proper range
			content = decHex(param[0]) + decHex(param[1]);
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "filterConfigRequest") { // verified
  	type = "10 bf 22";
		content = "01 00 00";

	} else if (requested == "controlConfigRequest1") { // verified
  	type = "10 bf 22";
		content = "02 00 00";

	} else if (requested == "controlConfigRequest2") { // verified -- unknown what response means
  	type = "10 bf 22";
		content = "04 00 00";

	} else if (requested == "controlConfigRequest3") {  // verified
  	type = "10 bf 22";
		content = "08 00 00";

	} else if (requested == "controlConfigRequest4") { // verifieate message
		if (message.type == "10 bf 06" && spa.outbox.length > 0) { // "Ready for command" (I think??) and messages ready to be sent
//console.log(spa.readyToSend, spa.waitingResponseTries)

// spa.waitingResponseTries is used both to wait for ready command a few times AND for the response confirmation
			if ((spa.readyToSend == "waiting on ready command" && spa.waitingResponseTries == 0) || spa.waitingResponseTries == 30) { // Ready command received or no confirmation received, so giving up
//console.log("executing message function")
				spa.outbox[0](); // Execute first message function in the queue (and probably the only one)
				spa.outbox.shift(); // Remove message function from queue
				spa.readyToSend = "waiting on response";
				spa.waitingResponseTries = 0;

// I think the console.log() is significantly slowing down the timing and causing some message not to be sent at the right time...
			} else if (spa.readyToSend == "waiting on ready command") { // Wait for a few  "Ready command" before sending next message
				spa.waitingResponseTries++;

			} else if (spa.readyToSend == "waiting on response") {
				spa.waitingResponseTries += 1;

			} else { // control variables have not been initialized yet
				spa.readyToSend = "waiting on ready command"
				spa.waitingResponseTries = 0;
			}

		} else if ((message.type in incoming && ignore.indexOf(message.type) == -1) || message.type == "ff af 13")  { // I have a definition for this message type and it is not in the ignore list or it's the regular status update

			let codeLine = incoming[message.type].codeLine; // Order of codes
			let codes = incoming[message.type].codes; // Translation of codes

			// Go through message content and translate byte by byte
			if (codeLine != undefined) { // Has a code line been defined for this message type ?
				for (let i=0; i<message.length; i++) {
					if (codeLine[i] in codes) { // If a code exists in codeLine, store in spa{}
						spa[codeLine[i]] = message.content[i]; // Update items in memory
						io.emit('data',{"id" : codeLine[i], "value" : spa[codeLine[i]]}); // Send to all connected clients
					}
				}
			}
		}
	}
}


function sendCommand(requested,param,callBackError) {
	console.log(requested)
  // Some messages need config requests to be sent first
  let type;
  let content = "";

	if (requested == "toggleItem") { // verified
  	type = "10 bf 11";

		let allowed = {"pump1" : "04", "pump2" : "05", "lights" : "11", "heatMode" : "51", "tempRange" : "50", "hold" : "3c"};
		if (param in allowed) {
			content = allowed[param] + "00";
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "setTemp") { // verified
  	type = "10 bf 20";
//range is 80-104 for F, 26-40 for C in high range
//range is 50-80 for F, 10-26 for C in low range
		if (param >= 50 && param <= 104) { // how to know if in low/high range???
			content = decHex(param);
			spa.lastChangeToTemp = new Date().getTime(); // Keep track of when temperature was changed (because of savElectricity() )
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "setTime") {  // Expects param to be in [HH,MM] format // verified
  	type = "10 bf 21";

		if (param[0] >=0 && param[0] <=23 && param[1] >=0 && param[1] <= 59) { // Check hours and minutes within proper range
			content = decHex(param[0]) + decHex(param[1]);
		} else {
			return callBackError("Error in " + requested);
		}

	} else if (requested == "filterConfigRequest") { // verified
  	type = "10 bf 22";
		content = "01 00 00";

	} else if (requested == "controlConfigRequest1") { // verified
  	type = "10 bf 22";
		content = "02 00 00";

	} else if (requested == "controlConfigRequest2") { // verified -- unknown what response means
  	type = "10 bf 22";
		content = "04 00 00";

	} else if (requested == "controlConfigRequest3") {  // verified
  	type = "10 bf 22";
		content = "08 00 00";

	} else if (requested == "controlConfigRequest4") { // verifie